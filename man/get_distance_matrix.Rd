% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_distance_mat.R
\name{get_distance_matrix}
\alias{get_distance_matrix}
\title{Compute all shortest distance between origin and destination nodes.}
\usage{
get_distance_matrix(Graph, from, to, aggregate_aux = FALSE, max_aux = Inf)
}
\arguments{
\item{Graph}{An object generated by \link{makegraph}, \link{cpp_simplify} or \link{cpp_contract} function.}

\item{from}{A vector of one or more vertices from which distances are calculated (origin).}

\item{to}{A vector of one or more vertices (destination).}

\item{aggregate_aux}{Logical. If \code{TRUE}, the additional weight is summed along shortest paths.}
}
\value{
Matrix of shortest distances.
}
\description{
Compute all shortest distance between origin and destination nodes.
}
\details{
\code{get_distance_matrix()} recursively perform Dijkstra algorithm for each \code{from} nodes.

Shortest path is always computed according to the main edge weights, corresponding to the 3rd column of \code{df} argument in \code{makegraph()} function.
If \code{aggregate_aux} argument is \code{TRUE}, the values returned are the sum of auxiliary weights along shortest paths.
}
\examples{
#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges <- data.frame(from_vertex = c(0,0,1,1,2,2,3,4,4),
                    to_vertex = c(1,3,2,4,4,5,1,3,5),
                    time = c(9,2,11,3,5,12,4,1,6),
                    dist = c(5,3,4,7,5,5,5,8,7))

#Construct directed  graph with travel time as principal weight, and distance as secondary weight
graph <- makegraph(edges[,1:3], directed=TRUE, aux = edges$dist)

#Get all nodes IDs
nodes <- graph$dict$ref

# Get matrix of shortest times between all nodes : the result are in time unit
time_mat <- get_distance_matrix(graph, from = nodes, to = nodes)

# Get matrix of distance according shortest times : the result are in distance unit
dist_mat <- get_distance_matrix(graph, from = nodes, to = nodes, aggregate_aux = TRUE)

print(time_mat)
print(dist_mat)
}
