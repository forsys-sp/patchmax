---
title: "Patchmax"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  message = FALSE,
  fig.path = 'man/figures/', 
  cache=F, 
  cache.path = 'misc/cache/')
```
 
<!--- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
devtools::load_all()
h = 6
w = 6
ow = "600"
```

<img src="man/figures/forsys_icon.png" align="right" style="height:90px!important; position:absolute; top:10px; right:10px" />

Patchmax is a computational module designed to explore spatially explicit landscape treatment projects. The package can be used to prioritize treatment locations on relatively small landscapes (project level implementation, 1,000 ha) to large landscapes (national forests to multi-regional planning efforts, 1 million ha). Although patchmax was originally designed for hazardous fuel treatment planning in forested systems, it can be applied to fiber production, habitat restoration, and other resource management problems. This version of Patchmax is based on a R6 objects and utilizes Djistra's algorithm to sequence stands within patches based on both adjacency and distance. 

*Dependences: R (>= 4.0.3) and packages (R6, igraph, dplyr, sf, furrr, purrr, proxy, cppRouting)*

## Installation

<<<<<<< Updated upstream
The current official version of the _patchmax_ package can be installed from [GitHub](https://github.com/forsys-sp/patchmax/). 
=======
Patchmax package can be installed from GitHub using the following code.
>>>>>>> Stashed changes

```{r, eval = FALSE}
if (!require(remotes)) install.packages("remotes")
remotes::install_github("forsys-sp/patchmax")
```

## Usage

<<<<<<< Updated upstream
```{r, eval = FALSE}
library(patchmax)
pm <- patchmax$new(...)
pm$area_max = 1200
pm$search()$build()$record()
```
=======
Stand treatment units are represented as polygons in a spatial vector format. Each polygon represents a different treatment unit with numerous attributes that can be used to prioritize or constrain patch construction. To start, let's load some example data included with patchmax. To keep things simple, we focus only a subset of the entire study area. Further below, we'll set up a scenairo where we create several patches in sequence that maximize priority *p4* up to a patch size of 1000 ha and a maximum cost of $50000
>>>>>>> Stashed changes

```{r, map_attributes, warning=FALSE, message=F}
library(dplyr)
library(sf)
library(purrr)

geom <- patchmax::test_forest %>% 
  filter(row > 20, row <= 40, col > 20, col <= 40)

geom %>% 
  select(matches('p[0-9]|t[0-9]|b[0-9]|m[0-9]|c[0-9]')) %>%
  plot(max.plot = 20, border=NA)
```

We can combined these data to create additional fields. For example, let's create a new field called cost, which we'll use later as a secondary constraint building patches. In this example, treatment costs range between 500 and 5000 dollars per 100 ha stand.

```{r, message=F}
geom <- geom %>% mutate(cost = ((p2 + p4 - c1) * 1000) + 3000)
plot(geom[,'cost'], border=NA)
```

Patchmax is written as R6 class, which uses a syntax that differs from functional programming design used in most R functions. We first create a patchmax object called `pm` using the `new` method in the `patchmax` class and specify five base parameters that required in every Patchmax run: the stand geometry, the fields names for the stand id, objective, and area, and finally the maximum area allowed in a patch.

<<<<<<< Updated upstream
```{r}
=======
```{r, message=F}
>>>>>>> Stashed changes
pm <- patchmax$new(
  geom = geom, 
  id_field = 'id', 
  objective_field = 'p4', 
  area_field = 'ha', 
  area_max = 1000)
```

<<<<<<< Updated upstream
The core purpose of patchmax is build spatially contiguous patches that maximizes some objective given some maximum size constraint. The example below shows how this is done over a series of steps: (1) patchmax searches for the best place, (2) builds that patch, (3) plots the patch, (4) records the patch, (5) describes the patch statistics.

```{r, message=FALSE, warning=FALSE, fig.height=3}
=======
The core purpose of patchmax is build spatial contiguous patches that maximizes some objective given some maximum size constraint. The example below shows how this is done over a series of steps: (1) patchmax searches for the best place based on the parameters given, (2) builds that patch, (3) records the patch, (4) plots the patch.

```{r, basic_example, message=F}
>>>>>>> Stashed changes
pm$search()
pm$build()
pm$record()
pm$plot()
pm$record()
pm$summarize()
```
<<<<<<< Updated upstream

Note that the same set of sequence of steps can be chained together into a single line: `pm$search()$build$plot()$record()$summarize()`, which shows how multiple actions can be combined in different ways to produce different results. 

## Simulating multiple projects
We can also run patchmax to simulate a set number of projects based on our pm object.


```{r, basic_example}
# First reset results
pm$reset()

# Simulate 10 projects and summarize results
pm$simulate(10)
pm$summarize()
=======
Note that the same set of sequence of steps can be chained together into a single line: `pm$search()$build()$plot()`. This is a distinct feature of R6 class objects that works similar to piping `|>`.

To get a better sense of how the patch is selected, let's look at the search results in more detail. The plot below shows the patch scores using each stand as a potential seed. Note how the stands recorded in the previous patch are excluded. While the search plot looks similar to stand plot of the priority `p4`, the values represent the potential objective score of a patch if it were built from that location. In this sense, patchmax works similar to a moving window spatial analysis 

```{r, search_example, message=F}
pm$search(search_plot = T)
>>>>>>> Stashed changes
```
Next we'll change a few additional parameters and see how this affects the search. Notice how two large blocks of the landscape are excluded due to the new treatment threshold.

<<<<<<< Updated upstream
## Studies
Belavenutti, Pedro, Alan A. Ager, Michelle A. Day, and Woodam Chung. 2022. Designing forest restoration projects to optimize the application of broadcast burning. Ecological Economics 201. doi: 10.1016/j.ecolecon.2022.107558.

Belavenutti, Pedro, Alan. A. Ager, Michelle A. Day, and Woodam Chung. 2022. Multi-objective scheduling of fuel treatments to implement a linear fuel break network. Fire 6:1. doi: 10.3390/fire6010001.

## Citation

Please cite the _patchmax_ package when using it in publications. To cite the current official version, please use:

```{r, echo = FALSE, results = "asis", comment = ""}
cat(paste0("> Evers C, Belavenutti P, Day M, Houtman R, and Ager A. (",format(Sys.time(), "%Y"),"). Patchmax: a spatial optimization package for building spatial priorities.. R package version 0.2.. Available at https://github.com/forsys-sp/patchmax.\n"))
```

## Getting help

If you have any questions about the _patchmax_ package or suggestions for improving it, please [post an issue on the code repository](https://github.com/forsys-sp/patchmax/issues/new).
=======
```{r}
pm$threshold = 't1 == 1'
pm$search(search_plot = T)
```
Next, let's add a secondary constraint that limits the overall cost of each patch to 15000. Note how this suppresses the search_out scores substantially; many of the potential patch locations that were able to produce high quality patches are now blue. This change is the result of the new cost constraint limiting patch sizes in many areas of the landscape from growing more than a few stands in size, hence the lower scores.

```{r, message=F}
pm$constraint_field = 'cost'
pm$constraint_max = 15000
pm$search(search_plot = T)
```
Adding a minimize patch size constrains potential projects further and remove additional sections of the landscape from consideration since no viable patches exist. 

```{r, message=F}
pm$area_min = 500
pm$search(search_plot = T)
```
As a final step, we'll reset the patchmax run and use the simulate method to identify the 10 highest prioirty patches given the area, cost, and threshold constraints. 

```{r, message = F}
pm$reset()
pm$simulate(10)
pm$plot()
pm$patch_stats
```

## Studies

Patchmax builds on an earlier implementation as described in Belavenutti et al. 2022 which pioneered the use of network search algorithms to prioritize patches. The current version was rewritten as an R6 object class and uses Dijstra's algorithm over breath first search in evaluating patches.

Belavenutti, Pedro, Alan A. Ager, Michelle A. Day, and Woodam Chung. 2022. Designing forest restoration projects to optimize the application of broadcast burning. Ecological Economics.
>>>>>>> Stashed changes
